#!/usr/bin/env python3
"""
generate_table.py

Reads platforms.json and generates COMPARISON.md ‚Äî a formatted
markdown comparison table grouped by platform category.

Usage:
    python generate_table.py

Output:
    COMPARISON.md (overwritten each run)
"""

import json
from pathlib import Path
from collections import defaultdict

# ‚îÄ‚îÄ Config ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

INPUT_FILE  = Path("platforms.json")
OUTPUT_FILE = Path("COMPARISON.md")

# How each feature value renders in the table
VALUE_EMOJI = {
    "yes":     "‚úÖ",
    "no":      "‚ùå",
    "partial": "‚ö†Ô∏è",
    "planned": "üóìÔ∏è",
    "unknown": "‚ùì",
}

# ‚îÄ‚îÄ Helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

def render_value(value: str) -> str:
    return VALUE_EMOJI.get(value.lower(), "‚ùì")

def platform_header(p: dict) -> str:
    return f"[{p['name']}]({p['url']})"

def build_category_table(platforms: list, features: list) -> str:
    """Build a markdown table for a single category group."""
    if not platforms:
        return ""

    # Header row
    col_headers = " | ".join(["**Feature**"] + [platform_header(p) for p in platforms])
    separator   = " | ".join(["---"] * (len(platforms) + 1))
    lines = [f"| {col_headers} |", f"| {separator} |"]

    # Architecture row (special ‚Äî plain text not emoji)
    arch_values = " | ".join(p.get("architecture", "‚Äî") for p in platforms)
    lines.append(f"| **Architecture** | {arch_values} |")

    # Group features by category
    feature_categories = defaultdict(list)
    for f in features:
        feature_categories[f["category"]].append(f)

    for cat_name, cat_features in feature_categories.items():
        # Category sub-header row (bold, spans full width via merged content)
        spacer_cells = " | ".join("„ÄÄ" for _ in platforms)  # full-width space
        lines.append(f"| **{cat_name}** | {spacer_cells} |")

        for feature in cat_features:
            fkey  = feature["key"]
            label = feature["label"]
            cells = []
            for p in platforms:
                raw   = p["features"].get(fkey, "unknown")
                emoji = render_value(raw)
                # Append note indicator if a note exists for this feature
                note  = p.get("feature_notes", {}).get(fkey, "")
                if note:
                    # GitHub markdown doesn't support tooltips natively in tables,
                    # so we append a ¬π marker ‚Äî notes are listed below each table
                    emoji += " ‚Ä†"
                cells.append(emoji)
            cell_str = " | ".join(cells)
            lines.append(f"| {label} | {cell_str} |")

    return "\n".join(lines)

def collect_notes(platforms: list) -> list[str]:
    """Collect all feature notes across a list of platforms."""
    notes = []
    for p in platforms:
        for fkey, note_text in p.get("feature_notes", {}).items():
            notes.append(f"- **{p['name']} ‚Äî {fkey.replace('_', ' ').title()}:** {note_text}")
    return notes

# ‚îÄ‚îÄ Main ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

def main():
    data = json.loads(INPUT_FILE.read_text(encoding="utf-8"))

    features   = data["features"]
    platforms  = data["platforms"]
    categories = data["categories"]

    # Group platforms by category preserving order from "categories" list
    grouped = defaultdict(list)
    for p in platforms:
        grouped[p["category"]].append(p)

    lines = []

    # ‚îÄ‚îÄ File header ‚îÄ‚îÄ
    lines += [
        "# üìä Platform Comparison",
        "",
        "> **This file is auto-generated from `platforms.json`.**  ",
        "> To make changes, edit `platforms.json` and re-run `python generate_table.py`.",
        "> Do not edit this file directly.",
        "",
        "## Legend",
        "",
        "| Symbol | Meaning |",
        "|---|---|",
        "| ‚úÖ | Fully supported |",
        "| ‚ö†Ô∏è | Partial support or limited |",
        "| üóìÔ∏è | Planned / in development |",
        "| ‚ùå | Not supported |",
        "| ‚ùì | Unknown / unverified |",
        "| ‚Ä† | See note below table |",
        "",
    ]

    # ‚îÄ‚îÄ One section per category ‚îÄ‚îÄ
    for category in categories:
        cat_platforms = grouped.get(category, [])
        if not cat_platforms:
            continue

        lines.append(f"---")
        lines.append(f"")
        lines.append(f"## {category}")
        lines.append(f"")

        # Optional category description
        descriptions = {
            "Matrix Clients": (
                "> All Matrix clients share the same underlying protocol ‚Äî "
                "federated, decentralized, and E2EE by default. "
                "Differences below are client-level features only.  \n"
                "> üí° **Homeserver needed:** Use [matrix.org](https://matrix.org) "
                "or self-host with [matrix-docker-ansible-deploy]"
                "(https://github.com/spantaleev/matrix-docker-ansible-deploy)."
            ),
            "Privacy-Focused Centralized": (
                "> These platforms prioritize privacy but run on central servers. "
                "Self-hosted instances exist but **cannot communicate with each other** ‚Äî "
                "they are isolated, not federated."
            ),
            "Self-Hosted Platforms": (
                "> Designed primarily for self-hosting. "
                "Most require technical knowledge to deploy."
            ),
            "Commercial Alternatives": (
                "> Polished commercial products. Included for completeness. "
                "Privacy policies and long-term direction may change."
            ),
            "Legacy & Niche": (
                "> Included for historical context or specific use cases. "
                "Generally not recommended as full Discord replacements."
            ),
        }
        if category in descriptions:
            lines.append(descriptions[category])
            lines.append("")

        lines.append(build_category_table(cat_platforms, features))
        lines.append("")

        notes = collect_notes(cat_platforms)
        if notes:
            lines.append("**‚Ä† Notes:**")
            lines += notes
            lines.append("")

    # ‚îÄ‚îÄ Footer ‚îÄ‚îÄ
    lines += [
        "---",
        "",
        "## ü§ù Contributing",
        "",
        "See an error or missing platform? Edit `platforms.json` and open a Pull Request.  ",
        "See [CONTRIBUTING.md](CONTRIBUTING.md) for guidelines.",
        "",
    ]

    OUTPUT_FILE.write_text("\n".join(lines), encoding="utf-8")
    print(f"‚úÖ Generated {OUTPUT_FILE} with {len(platforms)} platforms "
          f"across {len(categories)} categories.")

if __name__ == "__main__":
    main()
